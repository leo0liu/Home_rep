<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="452"/>

<div>
<span><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 19px;">安装Git</span></span></b></div><div><br/></div><div><br/></div><div><br/></div><div>msysgit是Windows版的Git，从https://git-for-windows.github.io下载（网速慢的同学请移步国内镜像），然后按默认选项安装即可。</div><div><br/></div><div>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</div><div><br/></div><div>install-git-on-windows</div><div><br/></div><div>安装完成后，还需要最后一步设置，在命令行输入：</div><div><br/></div><div>$ git config --global user.name &quot;Your Name&quot;</div><div>$ git config --global user.email &quot;email@example.com&quot;</div><div><br/></div><div>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</div><div><br/></div><div>注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">创建版本库</span></span></b></div><div><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></div><div>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>mkdir /e/learngit    创建一个路径文件夹作为仓库  英文路径!</div><div>cd learngit          进入这个路径下</div><div>pwd                  显示当前的目录路径    如:/Users/michael/learngit</div><div>le                   查看当前你所在文件路径下的 所有文件和文件夹信息</div><div>git init             初始化这个仓库   文件夹内有了git 隐藏文件   使用ls -ah 可以看见</div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div><div>使用Notepad++ 设置UTF-8 without BOM</div><div><br/></div><div>用notepad++创建一个文件夹 readme.txt </div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git add                               添加文件到缓存区</div><div>git add A/*                           添加A文件夹里的多个文件(1次添加多个文件)</div><div>git commit -m &quot;里面写这次修改的描述&quot;     提交到仓库</div></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">时光机穿梭</span></span></b></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git status       查看目前工作区 和缓存区 的状态(不包括最终提交到仓库的状态)</div><div>git diff         查看修改后 和 修改前的差异状态</div></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">版本回退</span></span></b></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git log                      查看显示从最近到最远的提交日志</div><div>git log --pretty=oneline     查看简单的提交日志(不会眼花缭乱)</div></div><div><br/></div><div>你看到的一大串类似3628164...882e1e0的是commit id（版本号）</div><div>在Git中，用HEAD表示当前版本,上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git reset --hard HEAD^        退回到上一个版本</div><div>git reset --hard 3628164      退回到指定的版本,(3628164是用git log查看到的版本号)</div><div>cat readme.txt                查看文件里的内容</div></div><div><br/></div><div>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</div><div><br/></div><div>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>$ git reflog    用来记录你的每一次命令(关机后也能查看)</div></div><div><br/></div><div><hr/></div><div><br/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">工作区和暂存区</span></span></b></div><div><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></div><div><img src="Gitaa_files/0.jpg" type="image/jpeg" style="height: auto;"/></div><div><br/></div><div>工作区  git add 后到达  stage(缓存区)  git commit -m&quot;&quot; 后 到达 master(仓库)</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">管理修改</span></span></b></div><div><br/></div><div>每次修改，如果不add到暂存区，那就不会加入到commit中。</div><div><br/></div><div>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</div><div>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">撤销修改</span></span></b></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git checkout -- readme.txt   在工作区的修改 且没有提交到缓存区 可以直接撤销</div></div><div><br/></div><div>命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</div><div><br/></div><div>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</div><div><br/></div><div>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git reset HEAD readme.txt    可以把工作区提交后到达暂存区的修改撤销掉，重新放回工作区(前提是没有提交到仓库区) (接着可以继续把工作区的撤销就世界清晰了)</div></div><div><br/></div><div>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</div><div><br/></div><div><br/></div><div>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</div><div><br/></div><div>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</div><div><br/></div><div>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">删除文件</span></span></b></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>rm test.txt    工作区的删除一个文件</div></div><div><br/></div><div>现在你有两个选择:</div><div><br/></div><div>一  是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</div><div><br/></div><div><br/></div><div>二  另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git rm test.txt                     把删除这个文件提交到缓存区</div><div>git commit -m &quot;remove test.txt&quot;     把删除这个文件提交到仓库</div><div><br/></div><div>git checkout -- test.txt            把工作区删除文件的状态撤销</div></div><div><br/></div><div><br/></div><div>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</div><div><br/></div><div>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">远程仓库</span></span></b></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;   把&quot;&quot;里换成你的邮箱地址</div></div><div><br/></div><div>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</div><div><br/></div><div>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</div><div><br/></div><div>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><br/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">添加远程库</span></span></b></div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div>本地已经有文件夹,去添加远程的一个新的仓库,登陆GitHub</div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div><br/></div><div>1.首先，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</div><div><br/></div><div>2.在Repository name填入你本地文件夹的名字，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：(不勾选Initialize this repository with a README )</div><div><br/></div><div>3.现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git remote add origin git@github.com:leo0liu/learngit.git    把:后面名字/文件夹名字填好, 关联本地文件夹和远程文件夹</div></div><div><br/></div><div>4.下一步，就可以把本地库的所有内容推送到远程库上：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git push -u origin master       把本地的文件都同步推送到远程github文件夹上</div></div><div><br/></div><div>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</div><div><br/></div><div>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</div><div><br/></div><div>5.从现在起，只要本地作了提交，就可以通过命令：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git push origin master     把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</div></div><div><br/></div><div><br/></div><div><br/></div><div>SSH警告</div><div><br/></div><div>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</div><div><br/></div><div>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</div><div><br/></div><div>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</div><div><br/></div><div>这个警告只会出现一次，后面的操作就不会有任何警告了。</div><div><br/></div><div>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">从远程库克隆到本地仓库</span></span></b></div><div><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></div><div>本地没有文件夹项目,是需要从远程github上clone一个项目</div><div><br/></div><div><br/></div><div><br/></div><div>1.首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</div><div><br/></div><div>2.我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：</div><div><br/></div><div>3.现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git clone git@github.com:leo0liu/gitskills.git     这是默认的克隆地址  把名字换成自己的.</div></div><div><br/></div><div>4.然后进入gitskills目录看看，已经有README.md文件了。</div><div><br/></div><div>注意:</div><div><br/></div><div>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</div><div><br/></div><div>你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/leo0liu/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</div><div><br/></div><div>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</div><div><br/></div><div><br/></div><div>有回答说:如果是window系统，将$ git clone git@github.com:liu9963xia/gitskills.git 改成 $ git clone https://github.com/leo0liu/gitskills.git 就行了</div><div><br/></div><div><br/></div><div><hr/></div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);">分支管理</span></span></b></div><div><br/></div><div>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</div><div><br/></div><div>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</div><div><br/></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">创建与合并分支</span></span></b></div><div><br/></div><div>Git鼓励大量使用分支</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git branch              查看分支    (列出所有分支)</div><div>git branch &lt;name&gt;       创建分支</div><div>git checkout &lt;name&gt;     切换分支   (带*号的是查看后的当期分支)</div><div>git checkout -b &lt;name&gt;  创建+切换分支  (-b=创建+切换分支  ,一般先使用这个)</div><div>git merge &lt;name&gt;        合并某分支到当前分支  (先切换到主分支master,再使用这个 name填分支名)</div><div>git branch -d &lt;name&gt;    删除分支 (合并完成后,查看主分支内容无误后,再删除分支)</div><div> </div></div><div><br/></div><div><br/></div><div><br/></div><div><hr/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">解决冲突</span></span></b></div><div><br/></div><div>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Git is a distributed version control system.</div><div>Git is free software distributed under the GPL.</div><div>Git has a mutable index called stage.</div><div>Git tracks changes of files.</div><div>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div>Creating a new branch is quick &amp; simple.</div><div>=======</div><div>Creating a new branch is quick AND simple.</div><div>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</div><div><br/></div><div>修改后</div><div><br/></div><div>Git is a distributed version control system.</div><div>Git is free software distributed under the GPL.</div><div>Git has a mutable index called stage.</div><div>Git tracks changes of files.</div><div>Creating a new branch is quick and simple.</div></div><div><br/></div><div><br/></div><div>用git log --graph命令可以看到分支合并图。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git log --graph --pretty=oneline --abbrev-commit    查看分支合并图</div></div><div><br/></div><div><br/></div><div>解决冲突思路:</div><div><br/></div><div>1.当两个修改后并且都提交到仓库的分支要合并时,但是都同时在一个地方做了修改是,就是下面图,这样合并会发生冲突</div><div><img src="Gitaa_files/6666.png" type="image/png" style="height: auto;"/></div><div>2.需要进入文件,查看内容, 把冲突的部分,选责一个留下来,其他删除.然后再次ADD 和提交上去,这样当前的分支就再次超前了一个提交,如下图.</div><div><br/></div><div><img src="Gitaa_files/0.png" type="image/png" style="height: auto;"/></div><div><br/></div><div>3.可用查看分支图命令查看效果.,然后删除多余的分支,,feature1,系统会选择最新的哪个融合版本保留 完成.</div><div><br/></div><div><hr/></div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">分支管理策略</span></span></b></div><div><br/></div><div><br/></div><div>在实际开发中，我们应该按照几个基本原则进行分支管理：</div><div><br/></div><div>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</div><div><br/></div><div>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</div><div><br/></div><div>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</div><div><br/></div><div>所以，团队合作的分支看起来就像这样：</div><div><br/></div><div><img src="Gitaa_files/9.png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><br/></div><div>合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git merge --no-ff -m &quot;merge with no-ff&quot; dev   不使用快速合并,合并后删除分支有留有历史信息(dev为合并的分支名)</div></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">Bug分支</span></span></b></div><div><br/></div><div><br/></div><div>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</div><div><br/></div><div>流程: 把没有做完,还不能提交的分支储存起来,哪里有bug就切到哪个分支上开一个新的分支修改bug.修改完bug后, 再回到刚才开辟的那个分支上,合并分支,再删除bug分支.</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git stash           把当前工作现场“储藏”起来，等以后恢复现场后继续工作</div><div>git stash list      查看储存列表</div></div><div><br/></div><div>恢复储存到分支有两个方式:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">1.git stash pop               恢复的同时把stash内容删了</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">2.git stash apply             恢复后stash并不删除</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">  git stash drop              配合git stash apply后 使用,删除stash</span></span></span></div></div><div><br/></div><div>可以多次使用stash储存</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git stash apply stash@{0}       恢复指定的stash</div></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">Feature分支</span></span></b></div><div><b><span style="font-size: 21px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div><br/></div><div>开发一个新feature，最好新建一个分支</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git branch -d feature-vulcan  删除分支,feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan</div><div>git branch -D feature-vulcan  在没有合并的情况下,强行删除<br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><hr/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">多人协作</span></span></b></div><div><br/></div><div><br/></div><div>多人协作的工作模式通常是这样：</div><div><br/></div><div>1.首先，可以试图用git push origin branch-name推送自己的修改； (需要提交哪个分支就 branch-name填哪个分支的名字)</div><div><br/></div><div><br/></div><div>2.如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</div><div><br/></div><div><br/></div><div>3.如果合并有冲突，则解决冲突，并在本地提交；</div><div><br/></div><div><br/></div><div>4.没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</div><div><br/></div><div><br/></div><div>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。</div><div><br/></div><div>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git remote -v                    查看远程库信息</div><div>git pull                         从远程抓取分支(如果有冲突，要先处理冲突)</div><div>git checkout -b dev origin/dev   其他人clone时,只能看见master,如果需要其他的分支,用这个方法(•在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致)</div></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">标签管理</span></span></b></div><div><br/></div><div><br/></div><div>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</div><div><br/></div><div><br/></div><div>“请把上周一的那个版本打包发布，commit号是6a5819e...”</div><div><br/></div><div>“一串乱七八糟的数字不好找！”</div><div><br/></div><div>如果换一个办法：</div><div><br/></div><div>“请把上周一的那个版本打包发布，版本号是v1.2”</div><div><br/></div><div>“好的，按照tag v1.2查找commit就行！”</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">创建标签</span></span></b></div><div><br/></div><div><br/></div><div>在Git中打标签非常简单，首先，切换到需要打标签的分支上(一般为主分支)</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git tag v1.0            打标签 (默认为head ,最新状态的提交)</div><div><br/></div><div>git tag                 查看所有标签</div></div><div><br/></div><div>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</div><div><br/></div><div>方法是找到历史提交的commit id，然后打上就可以了 使用git log --pretty=oneline --abbrev-commit</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git tag v0.9 6223456    找到对应commit id 然后打一个对应该版本的标签</div><div><br/></div><div>git show v0.9           查看单独标签的信息</div><div><br/></div><div>git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164   创建带有说明的指定commit id标签</div><div><br/></div><div>git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a  创建一个带有说明的指定 commit id 的私钥标签</div></div><div><br/></div><div><br/></div><div>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>gpg: signing failed: secret key not available</div><div>error: gpg failed to sign the data</div><div>error: unable to sign the tag</div></div><div><br/></div><div>如果报错，请参考GnuPG帮助文档配置Key。</div><div><br/></div><div>用命令git show &lt;tagname&gt;可以看到PGP签名信息</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">操作标签</span></span></b></div><div><br/></div><div><br/></div><div>创建的标签不会在推送时自动的把标签推送到远程,所以需要推送标签要手动推送</div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git tag -d v0.1        删除标签</div><div><br/></div><div>git push origin v1.0   手动将v1.0推送到远程</div><div><br/></div><div>git push origin --tags  一次性推送所有没有推送到远程的本地标签</div><div><br/></div></div><div><br/></div><div>如果标签已经推送到远程，要删除远程标签就麻烦一点:</div><div><br/></div><div>1.先从本地删除</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git tag -d v0.9       删除本地的标签</div></div><div><br/></div><div>2.然后，从远程删除。删除命令也是push，但是格式如下</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git push origin :refs/tags/v0.9   删除远程标签</div></div><div><br/></div><div>要看看是否真的从远程库删除了标签，可以登陆GitHub查看</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">使用GitHub</span></span></b></div><div><br/></div><div><br/></div><div>1.fork一个项目</div><div><br/></div><div>2.克隆到本地</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git clone git@github.com:leo0liu/bootstrap.git    克隆到本地</div></div><div><br/></div><div>3.本地修改后,推送到远程,可以pull request,让项目拥有者查看是否需要认同你的想法</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><br/></div><div><b><span style="color: rgb(250, 122, 0);"><span style="font-size: 21px;">自定义Git</span></span></b></div><div><br/></div><div>让Git显示颜色，会让命令输出看起来更醒目</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>git config --global color.ui true     (小心true 的拼写)</div></div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div><br/></div></span>
</div></body></html> 